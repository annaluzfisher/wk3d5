#tree adt is a web of nodes

#trees have MAXIMUM one parent
#binary tree - two kids
#turniary tree - three kids
# n tre....
#depth is the deistance from the top of the tree
# width is how far from node with no kid
#root is node iwthout a parent
#internal node has at least
#depth of node - distance from root
#heigh of node - distance from leaf (dist colosest node)

class Node

        attr_reader :value , :children
    def initialize (value, children = [])
        @value = value
        @children = children 
    end

    def inspect

    end
        # def build_move_tree(pos)
        #     root = Node.new(.......)
        # end
end
d = Node.new("d") 
e = Node.new("e") 
g = Node.new("g") 
f = Node.new("f") 
b = Node.new("c", [d,e]) 
c = Node.new("g",[f,g]) 
a = Node.new("a" [b,c]) 

#TREE TRAVERSAL ALGORITHMS 
#algorithm general approaches to process solving (binary searcing through array etc)
#function or method is the implementation of the algorithm 
#NODE TO BE AS SHALLOW  - Breadth first search (BFS)
# if i know it's not going to be acchievable in one or two moves, doing a (DFS)

   def dfs(node,tar)
    return node if node.value = target     # we have addr reader for value 
    return nil if node.children.length == 0
    node.children.each do |child|                   #node because not in Class, not monkeypatching
        res = dfs(child,tar)
        return res unless res.nil?
        end
   end


   p dfs(a,"e")

def bfs(node, tar)
    q = MyQueue.new
    q.enqueue(node)
    while (q.size > 0)
        curr_node = q.dequeue
        return curr_node if curr_node.value = target
        curr_node.children.each {|ele| q.enqueue(ele)}
    end
    nil
end
    
